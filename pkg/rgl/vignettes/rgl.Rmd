---
title: "rgl Overview"
author: "Duncan Murdoch"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
vignette: >
  %\VignetteIndexEntry{rgl Overview} 
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, echo=FALSE}
source("setup.R")
set.seed(123)
```



## Introduction

The `rgl` package is used to produce interactive 3-D plots.  It contains
high-level graphics commands modelled loosely after classic R graphics,
but working in three dimensions.  It also contains low level structure
inspired by the `grid` package.

This document gives an overview.  See the help pages for details.

## Basics and High Level Functions

The `r indexfns("plot3d")` function
plots points within an rgl window.  It is similar to the classic 
`plot` function,
but works in 3 dimensions.

For example
```{r plot3d, rgl=TRUE}
with(iris, plot3d(Sepal.Length, Sepal.Width, Petal.Length, 
                  type="s", col=as.numeric(Species)))
```
can be used to plot three columns of the `iris` data.  
Allowed plot types include `"p", "l", "h", "s"`,
meaning points, lines, segments from z=0, and spheres.  There's
a lot of flexibility in specifying the coordinates; the `xyz.coords` function
from the `grDevices` package is used for this.

You can use your mouse to manipulate the plot.  The default is that
if you click and hold with the left mouse button, you can rotate 
the plot by dragging it.  The right mouse button is used to resize
it, and the middle button changes the perspective in the point of view.

If you call `r linkfn("plot3d")` again, it will overwrite the current plot.
To open a new graphics window, use `r linkfn("open3d")`.
 
The other high level function is `r indexfns("persp3d")` to draw surfaces.
It is
similar to the classic `persp` function, but with greater flexibility.
First, any of `x`, `y` or `z`
can be specified using matrices, not just `z`.  This allows parametric
surfaces to be plotted. 
An even simpler specification is possible:  `x` may be a function,
in which case `persp3d` will work out the grid itself.  See 
`?persp3d.function` for details.  For example, the `MASS` package estimates
Gamma parameters using maximum likelihood in a `?MASS::fitdistr` example.
Here we show the log likelihood surface:
```{r persp3d, rgl=TRUE}
library(MASS)
# from the fitdistr example
set.seed(123)
x <- rgamma(100, shape = 5, rate = 0.1)
fit <- fitdistr(x, dgamma, list(shape = 1, rate = 0.1), lower = 0.001)
loglik <- function(shape, rate) sum(dgamma(x, shape=shape, rate=rate, 
                                           log=TRUE))
loglik <- Vectorize(loglik)
persp3d(loglik, 
        xlim = fit$estimate[1]+2*fit$sd[1]*c(-1,1),
        ylim = fit$estimate[2]+2*fit$sd[2]*c(-1,1),
        n = 30)
```

## Adding Graphical Elements

Just as we have `points` and `lines` in classic graphics, there are a number
of low level functions in `rgl` to add graphical elements to the
currently active plot.

--------------

----------------------------- | -----------
`r indexfns("points3d")`:     | adds points
`r indexfns("lines3d")`:      | adds lines
`r indexfns("segments3d")`:   | adds line segments
`r indexfns("triangles3d")`:  | adds triangles
`r indexfns("quads3d")`:      | adds quadrilaterals
`r indexfns(c("text3d", "texts3d"))`: | adds text
`r indexfns("abclines3d")`:   | adds straight lines to plot (like `abline`)
`r indexfns("planes3d")`:     | adds planes to plot
`r indexfns("clipplanes3d")`: | add clipping planes to plot
`r indexfns(c("sprites3d", "particles3d"))`: | add sprites (fixed shapes or images) to plot
`r indexfns("spheres3d")`:    | adds spheres
`r indexfns(c("surface3d", "terrain3d"))`:    | a surface (as used in `r linkfn("persp3d")`)

------------

Each of the above functions takes arguments `x`, `y` and `z`, again
using `xyz.coords` for flexibility.  They group successive entries
as necessary.  For example, the `r linkfn("triangles3d")` function takes each
successive triple of points as the vertices of a triangle.

You can use these functions to annotate the current graph, or to 
construct a figure from scratch.

The following low-level functions control the look of the graph:

--------------

------------------------------------ | -----------
`r indexfns(c("axes3d", "axis3d"))`: | add axes to plot
`r indexfns(c("box3d", "bbox3d"))`:               | add box around plot
`r indexfns("title3d")`:             | add title to plot
`r indexfns("mtext3d")`:             | add marginal text to plot
`r indexfns("decorate3d")`:          | add multiple "decorations" (scales, etc.) to plot
`r indexfns("aspect3d")`:            | set the aspect ratios for the plot
`r indexfns(c("bg3d", "bgplot3d"))`: | set the background of the scene
`r indexfns("legend3d")`:            | set a legend for the scene
`r indexfns("grid3d")`:              | add a reference grid to a graph

---------------

For example, to plot three random triangles, one could use
```{r echo=FALSE, results="hide"}
rgl.close()
open3d()
```
```{r rgl=TRUE}
triangles3d(cbind(x=rnorm(9), y=rnorm(9), z=rnorm(9)), col = "green")
decorate3d()
bg3d("lightgray")
aspect3d(1,1,1)
```

Besides the `*3d` functions mentioned above, there are even lower-level
functions 
`r indexfns(c("rgl.points", "rgl.linestrips", "rgl.lines", "rgl.triangles",
"rgl.quads", "rgl.texts", "rgl.abclines", "rgl.planes", "rgl.bg",
"rgl.clipplanes", "rgl.bbox", "rgl.spheres", "rgl.sprites", "rgl.surface"))`.  
You should avoid using these functions, which do not
work well with the higher level `*3d` functions.  See the `?r3d` help
topic for details.

## Materials, Lights and par3d()

## Meshes:  Constructing Shapes 

`rgl` includes a number of functions to construct and display 
various solid shapes.  These generate objects of class `"shape3d"`,
`"mesh3d"` or `"shapelist3d"`.  The details of the classes are 
described below.  We start with functions to generate them.

### Specific solids

These functions generate specific shapes.  Optional arguments allow
attributes such as colour or transformations to be specified.

--------------

------------------------------------ | -----------
`r indexfns(c("tetrahedron3d", "cube3d", "octahedron3d"))`: | Platonic solids
`r indexfns(c("dodecahedron3d", "icosahedron3d"))`:        | more Platonic solids
`r indexfns(c("cuboctahedron3d", "oh3d"))`:             | other solids

---------------

```{r results="hide",rgl=TRUE,fig.height=2,fig.width=9}
open3d()
cols <- rainbow(7)
layout3d(matrix(1:14, 2,7), heights=c(1,3))
text3d(0,0,0,"tetrahedron3d"); next3d()
shade3d(tetrahedron3d(col=cols[1])); next3d()
text3d(0,0,0,"cube3d"); next3d()
shade3d(cube3d(col=cols[2])); next3d()
text3d(0,0,0,"octahedron3d"); next3d()
shade3d(octahedron3d(col=cols[3])); next3d()
text3d(0,0,0,"dodecahedron3d"); next3d()
shade3d(dodecahedron3d(col=cols[4])); next3d()
text3d(0,0,0,"icosahedron3d"); next3d()
shade3d(icosahedron3d(col=cols[5])); next3d()
text3d(0,0,0,"cuboctahedron3d"); next3d()
shade3d(cuboctahedron3d(col=cols[6])); next3d()
text3d(0,0,0,"oh3d"); next3d()
shade3d(oh3d(col=cols[7]))
```

### Generating new shapes 

These functions generate new shapes:

--------------

------------------------------------ | -----------
`r indexfns("cylinder3d")`: | generate a tube or cylinder
`r indexfns("polygon3d")`:  | generate a flat polygon by triangulation
`r indexfns("extrude3d")`:  | generate an "extrusion" of a polygon
`r indexfns("turn3d")`:     | generate a solid of rotation
`r indexfns("ellipse3d")`:  | generate an ellipsoid in various ways
`r indexfns(c("tmesh3d", "qmesh3d"))`:  | generate a shape from vertices and faces
`r indexfns("shapelist3d")`: | generate a shape by combining other shapes

---------------

A related function is `r indexfns("triangulate")`, which takes a
two dimensional polygon and divides it up into triangles using the 
"ear-clipping" algorithm.

### The underlying class structure for shapes

`"shape3d"` is the basic abstract type.  Objects of this class can be
displayed by `r indexfns("shade3d")` (which shades faces), 
`r indexfns("wire3d")` (which draws edges), or `r indexfns("dot3d")`
(which draws points at each vertex.)  Note that `wire3d` and `dot3d`
only work within R; in HTML output from `r linkfn("writeWebGL")` only
`shade3d` is supported.

`"mesh3d"` is a descendant type.  Objects of this type contain the following 
fields:

Field        | Meaning
------------ | ---------------
vb           | A 4 by n matrix of vertices in homogeneous coordinates.  Each column is a point.
it           | (optional) A 3 by t matrix of vertex indices.  Each column is a triangle.
ib           | (optional) A 4 by q matrix of vertex indices.  Each column is a quadrilateral.
material     | (optional) A list of material properties.
normals      | (optional) A matrix of the same shape as vb, containing normal vectors at each vertex.
texcoords    | (optional) A 2 by n matrix of texture coordinates corresponding to each vertex.

### Manipulating shapes

The final set of functions manipulate and modify mesh objects:

--------------

------------------------------------ | -----------
`r indexfns("addNormals")`: | add normal vectors to make a shape look smooth
`r indexfns("subdivision3d")`: | add extra vertices to make it look even smoother

---------------

## Multi-figure Layouts

`rgl` has several functions to support displaying multiple different
"subscenes" in the same window.  The high level functions are

--------------

------------------------------------ | -----------
`r indexfns("mfrow3d")`:  | Multiple figures (like `par("mfrow")`)
`r indexfns("layout3d")`: | Multiple figures (like `layout`)
`r indexfns("next3d")`:   | Move to the next figure (like `plot.new` or `frame`)
`r indexfns("subsceneList")`: | List all the subscenes in the current layout
`r indexfns("clearSubsceneList")` | Clear the current list and revert to the previous one

---------------

There are also lower level functions.

--------------

------------------------------------ | -----------
`r indexfns("newSubscene3d")`:     | Create a new subscene, with fine control over what is inherited from the parent
`r indexfns("currentSubscene3d")`: | Report on the active subscene
`r indexfns("subsceneInfo")`:      | Get information on current subscene
`r indexfns("useSubscene3d")`:     | Make a different subscene active
`r indexfns(c("addToSubscene3d", "delFromSubscene3d"))`: | Add objects to a subscene, or delete them
`r indexfns("gc3d")`:              | Do "garbage collection":  delete objects that are not displayed in any subscene

---------------


## Utility Functions


### User interaction

By default, `rgl` detects and handles mouse clicks within your scene,
and uses these to control its appearance.  You can find out the current
handlers using the following code:
```{r}
par3d("mouseMode")
```
The labels `c("left", "right", "middle")` refer to the buttons on
a three button mouse, or simulations of them on other mice.  `"wheel"` 
refers to the mouse wheel.

The button actions generally correspond to click and drag operations.
Possible actions for buttons or the wheel are as follows:

-------------

--------       | ---------
`"none"`       | No action
`"trackball"`  | The mouse acts as a virtual trackball. Clicking and dragging rotates the scene
`"xAxis"`, `"yAxis"`, `"zAxis"`      | Like `"trackball"`, but restricted to rotation about one axis
`"polar"`      | The mouse affects rotations by controlling polar coordinates directly
`"selecting"`  | The mouse is being used by the `r linkfn("select3d")` function
`"zoom"`       | The mouse zooms the display
`"fov"`        | The mouse affects perspective by changing the field of view
`"pull"`       | Rotating the mouse wheel towards the user "pulls the scene closer"
`"push"`       | The same rotation "pushes the scene away"
`"user"`       | A user action set by `r linkfn("rgl.setMouseCallbacks")` or `r linkfn("rgl.setWheelCallback")`

----------------

The following functions make use of the mouse for selection within a 
scene.

--------------

---------------------------- | -----------
`r indexfns("identify3d")`   | like the classic graphics `identify` function
`r indexfns("select3d")`     | returns a function that tests whether a coordinate was selected

---------------

The `r indexfns("rgl.select3d")` function is an obsolete version of `select3d`.

### Working with the scene

`rgl` maintains internal structures for all the scenes it displays.
The following functions allow users to find information about them
and manipulate them.

--------------

------------------------------------ | -----------
`r indexfns("open3d")`               | open a new window
`r indexfns("rgl.close")`            | close the current window
`r indexfns("rgl.bringtotop")`       | bring the current window to the top
`r indexfns("rgl.cur")`              | id of the active device
`r indexfns("rgl.dev.list")`         | ids of all active devices
`r indexfns("rgl.set")`              | set a particular device to be active
`r indexfns("rgl.ids")`              | ids and types of all current objects
`r indexfns(c("rgl.attrib", "rgl.attrib.count"))`: | attributes of objects in the scene
`r indexfns(c("pop3d", "rgl.pop"))`     | delete an object from the scene
`r indexfns(c("clear3d", "rgl.clear"))`            | delete all objects of certain classes

---------------

In addition to these, there are some other related functions which
should rarely be called by users: `r indexfns(c("rgl.init", "rgl.open", "rgl.quit"))`.  


### Working with homogeneous coordinates

Most `rgl` functions work internally with "homogeneous" coordinates.
In this system, 3-D points are represented with 4 coordinates, generally
called (x, y, z, w).  The corresponding Euclidean point is
(x/w, y/w, z/w), if w is nonzero; zero values of w correspond to 
"points at infinity".  The advantage of this system is that
affine transformations including translations and perspective shifts
become linear transformations, with multiplication by a 4 by 4 matrix.

`rgl` has the following functions to work with homogeneous coordinates:

--------------

------------------------------------ | -----------
`r indexfns(c("asEuclidean", "asHomogeneous"))`: | convert between homogeneous and Euclidean coordinates
`r indexfns(c("rotate3d", "scale3d", "translate3d"))`:  | apply a transformation
`r indexfns("transform3d")`:  | apply a general transformation
`r indexfns(c("rotationMatrix", "scaleMatrix", "translationMatrix"))`:  | compute the transformation matrix
`r indexfns("identityMatrix")` | return a 4 x 4 identity matrix

---------------



## Warning:  Work in Progress!

This vignette is in a very preliminary form.  Many aspects of the rgl
package are not described yet.  There is still no documentation here for the
following functions.  You'll have to read the online help for these:
```{r echo=FALSE}
setdiff(ls("package:rgl"), documentedfns)
```

## Index of Functions

The following functions are described in this document:<br>
```{r echo=FALSE, results="asis"}
writeIndex(cols = 6)
```

This document was produced using rgl version `r packageVersion("rgl")`.

