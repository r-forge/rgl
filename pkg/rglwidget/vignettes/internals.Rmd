---
title: "rglwidget internals"
author: "Duncan Murdoch"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  rmarkdown::html_vignette:
    toc: yes
    fig_width: 5
    fig_height: 5
vignette: >
  %\VignetteIndexEntry{rglwidget internals} 
  %\VignetteEngine{knitr::rmarkdown}
---

# Introduction

The `htmlwidget` framework includes both R and Javascript
code.  We'll describe each part in turn, from the top (R level) down.

# rglwidget()

The `rglwidget()` function adds an `rgl` scene to the final web page.

It has static local storage `reuseDF` 
to store information about objects for re-use in later widgets.
This is `NULL` or a dataframe from the `reuse` attribute
of the `convertScene()` result, containing columns `id`, 
`elementId`, `texture`.

If not running in Shiny and not specified in the call, it
assigns a random `elementId` of the form `rglNNNNN`, where
`NNNNN` is 1 to 5 digits.

The value sent as `x` to `createWidget` is produced from
a `scene3d()` record with the following changes:
 
 - All objects including subscenes are included in the `objects` list.  The `rootSubscene` record is replaced with
 its id.
 
 - The `objects` list is named with character string versions
 of the object ids.  They are also kept redundantly as a field
 within the record.
 
 - If an object is in the `reuseDF` dataframe, it is replaced
 with `list(id = <id>, reuse = <elementId>)`.
 
 - `bboxdeco` objects are replaced with primitive versions.
 
 - `flags` are converted to numeric form.
 
 - The model sphere is stored in `sphereVerts`.
 
 - the `par3d$viewport` settings are adjusted in subscenes.
 
 - within individual objects, the `colors` element is dropped
   from the material (since it has already been converted to
   numerical RGB components, it is not needed).
 
 
# rglwidget.js

The `createWidget()` call puts `x` into JSON and calls
the `renderValue` function of the `rglwidget`.  This function
initializes a new `rglwidgetClass` object using the 
`<div>` element and `x`, then checks for uninitialized
controllers and initializes them.

Finally it draws the scene.

# rglcontroller()

The `rglcontroller()` function adds a controller to the page.
Most of the controllers are not visible; they are mainly
for use by Shiny controls to affect an `rglwidget()` scene.

As with `rglwidget()`, a random `elementId` (of the same form)
is generated if not supplied (and not running in Shiny).  

`sceneId` and `respondTo` are HTML ids of the scene to control
and the Shiny control to respond to, respectively.  These and
a list of individual controls are put into a list and passed
as `x` to `createWidget()`.

# playwidget()

This function is similar to `rglcontroller()`, but it always inserts
a `type = "player"` control.  That control inserts buttons, a 
slider, and a label into the web page, and uses them
to control a timer.


# subsetControl, propertyControl, ageControl, vertexControl

These are the controls that can be passed in `rglcontroller()` or
`playwidget()`.  Each of them sets up data and returns a list
with a field `type` to identify the control and various other
fields to hold data.

# rglcontroller.js

The `createWidget()` call puts `x` into JSON and calls
the `renderValue` function of the `rglcontroller`.  This function
attempts to call the `scene.applyControls` corresponding to the
`sceneId`, but it is possible the scene doesn't exist yet.  In that
case we just save the information in the instance data.

If `respondTo` is non-null, we hook into the `onchange` handler
on the named control.  (We chain older handlers, but 
some sketchy code tries not to chain to previous versions of
the same controller hook.)

# rglClass.src.js

Most of the Javascript code handling drawing is present as
methods of  `rglwidgetClass`.  Unlike the old
`rgl::writeWebGL`, the shaders are generated in Javascript
so changes to objects can result in new shaders being
generated.  Each object is initialized once, then drawn
many times as the viewpoint changes.  Adding or removing 
an object from a scene causes it to be re-initialized.

The `scene.applyControls` method is also part of this class.
It directs handling to separate functions depending on the
value of the `type` field in the control.

The `rglTimerClass` is a class to manage a timer created
by `playwidget()`.  
